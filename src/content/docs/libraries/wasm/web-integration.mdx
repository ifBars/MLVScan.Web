export default function WasmIntegrationContent() {
  return (
    <>
      <p className="text-gray-300 mb-6">
        The web app consumes the <strong className="text-white">@mlvscan/wasm-core</strong> npm package, which wraps the .NET 8 WASM runtime and MLVScan.WASM assembly. The package loads <code>dotnet.js</code> and the <code>_framework</code> assets for you; you do not copy <code>_framework</code> into your app’s <code>public</code> folder. Install from npm (<code>@mlvscan/wasm-core</code>); for local development you can use <code>file:../path/to/MLVScan.WASM/npm</code> and configure your bundler to serve or copy <code>_framework</code> from <code>node_modules/@mlvscan/wasm-core/dist/_framework</code>.
      </p>

      <h2 id="prerequisites">Prerequisites</h2>
      <ul className="list-disc list-inside space-y-2 text-gray-300 mb-6 ml-4">
        <li>Add <code>@mlvscan/wasm-core</code> from npm (or <code>file:</code> link to the WASM repo’s <code>npm</code> folder for local development).</li>
        <li>For local testing: build the MLVScan.WASM .NET project, then run <code>npm run copy:framework</code> in the package so <code>dist/_framework</code> is populated.</li>
        <li>Configure your dev server and build to serve or copy <code>_framework</code> from the package (e.g. Vite plugin to serve <code>/_framework</code> from the package in dev and copy to output on build).</li>
      </ul>

      <h2 id="api-overview">API Overview</h2>
      <p className="text-gray-300 mb-4">
        The package exposes: <code>initScanner</code>, <code>scanAssembly</code>, <code>getScannerVersion</code>, <code>getSchemaVersion</code>, <code>isScannerReady</code>, <code>isMockScanner</code>, <code>getInitError</code>, and <code>getScannerStatus</code>. Call <code>initScanner</code> once (or let <code>scanAssembly</code> / <code>getScannerVersion</code> init on first use). Use the status and error APIs to show “Scanner unavailable” or “Mock mode” in the UI.
      </p>

      <h3 id="1-initializing">1. Initializing the Scanner</h3>
      <p className="text-gray-300 mb-4">
        Pass <code>baseUrl</code> so the runtime can load <code>_framework/dotnet.js</code>. Use <code>throwOnInitFailure: true</code> if you want init to throw instead of falling back to mock when WASM fails to load.
      </p>
      <pre className="bg-gray-800 rounded-lg p-4 mb-6 overflow-x-auto">
        <code className="text-sm text-gray-300">{`import { initScanner, getScannerStatus } from '@mlvscan/wasm-core'

await initScanner({
  baseUrl: '/',                    // or your app base path, e.g. '/MLVScan.Web/'
  useMock: false,                  // set true to force mock (e.g. for tests)
  throwOnInitFailure: false,       // set true to throw instead of falling back to mock
})

const status = getScannerStatus()
if (status.initError) {
  console.warn('Scanner unavailable:', status.initError.message)
}
if (status.isMock) {
  console.info('Running in mock mode', status.mockRequestedExplicitly ? '(requested)' : '(fallback)')
}`}</code>
      </pre>

      <h3 id="2-scanning-files">2. Scanning Files</h3>
      <p className="text-gray-300 mb-4">
        <code>scanAssembly</code> accepts a <code>Uint8Array</code> and file name, and returns a typed <code>ScanResult</code>. It will initialize the scanner if needed. In mock mode it returns a result with zero findings and <code>scannerVersion: '1.0.0-mock'</code>.
      </p>
      <pre className="bg-gray-800 rounded-lg p-4 mb-6 overflow-x-auto">
        <code className="text-sm text-gray-300">{`import { scanAssembly } from '@mlvscan/wasm-core'

export async function scanFile(file: File) {
  const arrayBuffer = await file.arrayBuffer()
  const fileBytes = new Uint8Array(arrayBuffer)
  const result = await scanAssembly(fileBytes, file.name)
  return result
}`}</code>
      </pre>

      <h3 id="3-error-and-status">3. Error and Status</h3>
      <p className="text-gray-300 mb-4">
        Use <code>getScannerStatus()</code> for a single snapshot of ready, mock, and init error. Use <code>getInitError()</code> and <code>isMockScanner()</code> when you only need the error or a mock flag.
      </p>
      <pre className="bg-gray-800 rounded-lg p-4 mb-6 overflow-x-auto">
        <code className="text-sm text-gray-300">{`import { isScannerReady, isMockScanner, getInitError, getScannerVersion } from '@mlvscan/wasm-core'

if (!isScannerReady()) {
  // Still loading or init failed and not using mock
  return
}
const version = await getScannerVersion()
if (isMockScanner()) {
  // Show "Mock mode" badge; version will be '1.0.0-mock'
}
const err = getInitError()
if (err) {
  // Show "Scanner unavailable: " + err.message
}`}</code>
      </pre>

      <h2 id="deployment-notes">Deployment Notes</h2>
      <ul className="list-disc list-inside space-y-2 text-gray-300">
        <li><strong className="text-white">Caching:</strong> Browsers aggressively cache WASM files. Use cache-busting or versioned paths if you update the scanner frequently.</li>
        <li><strong className="text-white">MIME Types:</strong> If hosting on IIS or Azure Static Web Apps, ensure <code>.blat</code> and <code>.dat</code> MIME types are configured as <code>application/octet-stream</code>.</li>
        <li><strong className="text-white">Github Pages:</strong> Works out of the box with the default <code>.nojekyll</code> file present.</li>
      </ul>
    </>
  )
}
